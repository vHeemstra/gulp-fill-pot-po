name: PR labeler

on:
  workflow_dispatch:

  # pull_request:
  #   types: [opened, reopened, synchronize, edited, unlocked]

jobs:
  update_labels:
    name: Update labels
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          # token: ${{ secrets.GH_PERSONAL_ACCESS_TOKEN }}

# ${{ github.event.pull_request.number }}
# ${{ github.event.pull_request.title }}
# ${{ github.event.pull_request.body }}
# ${{ github.event.pull_request.labels }}
# ${{ github.event.pull_request.head.sha }}
# ${{ github.event.pull_request.base.sha }}
# ${{ github.event.pull_request.merged }}

      - name: Read package.json into ENV variable
        run: |
        echo 'PACKAGE_JSON<<EOF' >> $GITHUB_ENV
        cat ./package.json >> $GITHUB_ENV
        echo 'EOF' >> $GITHUB_ENV
      - name: Echo package version
        run: |
        echo 'Package version: ${{ fromJson(env.PACKAGE_JSON).version }}'

      - name: Fetch branch names
        uses: actions/github-script@v6
        id: fetch-branch-names
        with:
          # github-token: ${{ secrets.GH_PERSONAL_ACCESS_TOKEN }}
          script: |
            const pkg = require('./package.json');
            console.log( pkg );
            core.startGroup('\u001b[48;2;255;0;128mDependencies');
            console.log( [ ...pkg.dependencies.keys() ] );
            core.endGroup();
            return;
            // const getSemverChange = require('./.github/workflows/get-semver-change.js');

            const pr = context.payload.pull_request;
            const pr_files = await github.paginate(
              'GET /repos/{owner}/{repo}/pulls/{pull_number}/files',
              { owner, repo,
                pull_number: pr.number
              }
            );
            const pr_commits = await github.paginate(
              'GET /repos/{owner}/{repo}/pulls/{pull_number}/commits',
              { owner, repo,
                pull_number: pr.number
              }
            );

            const pr_labels = pr.labels.map( l => l.name );
            let new_pr_labels = pr_labels.slice();
            let subject_labels = [];
            let semver_label = 'none';

            /*
             * Count changed files per category
             */
            let changed = {
              ci: 0,
              ci_yml: 0,
              package_json: 0,
              package_src: 0,
              package_extras: 0,
              test_js: 0,
              test_pots: 0,
              test_config: 0,
              dev_config: 0,
              docs: 0,
            };
            pr_files.map( f => {
              if ( f.filename.match( /^\.github\/.+\.yml$/ ) ) {
                changed.ci++;
                changed.ci_yml++;
              } else if ( f.filename.match( /^\.github\// ) ) {
                changed.ci++;
              } else if ( f.filename.match( /^package(?:-lock)?\.json$/ ) ) {
                changed.package_json++;
              } else if ( f.filename.match( /^(?:index|src\/.+)\.js/ ) ) {
                changed.package_src++;
              } else if ( f.filename.match( /^(?:\.npmignore|LICEN[SC]E)$/ ) ) {
                changed.package_extras++;
              } else if ( f.filename.match( /^test\/.+\.js$/ ) ) {
                changed.test_js++;
              } else if ( f.filename.match( /^test\/.+\.pot?$/ ) ) {
                changed.test_pots++;
              } else if ( 'jest.config.js' === f.filename ) {
                changed.test_config++;
              } else if ( f.filename.match( /^\.(?:git(?:ignore|attributes)|editorconfig|eslintrc\.js)$/ ) ) {
                changed.dev_config++;
              } else if ( 'README.md' === f.filename || 'logo.svg' === f.filename ) {
                changed.docs++;
              }
            } );

            /*
             * Subject labels
             */
            if ( pr.user.login === 'dependabot[bot]' ) {
              subject_labels.push('dependencies');
              pr_commits.map( c => {
                const msg = c.commit.message;
                if (
                  msg.match( /^\s*dependency-type: direct:development/m )
                  || changed.ci_yml > 0
                ) {
                  subject_labels.push('development');
                } else if ( msg.match( /^\s*update-type: version-update:semver-(?:major|minor|patch)/m ) ) {
                  subject_labels.push('package');
                }
              } );
            } else {
              pr_files.map( f => {
                if ( f.filename.match( /^package(?:-lock)?\.json/ ) ) {
                  subject_labels.push('triage');
                } else if ( 'README.md' === f.filename ) {
                  subject_labels.push('documentation');
                }
              } );
              subject_labels.push('dependencies');
            }
            // pr_files.map( f => f.filename )
            new_pr_labels.push( ...subject_labels );


            /*
             * Semver labels
             */
            // ...
            if ( semver_label.length > 0 ) {
              new_pr_labels = new_pr_labels.filter( l => ( ! l.match( /^semver-/ ) ) );
              new_pr_labels.push('semver-' + semver_label );
            }


            /*
             * Request review if 'triage' was added
             */
            if ( ! pr_labels.includes('triage') && new_pr_labels.includes('triage') ) {
              //TODO: request review
            }


            // pr.number
            // pr.title
            // pr.body
            // * pr.labels
            // pr.head.sha
            // pr.base.sha
            // pr.merged
            // pr.user.login === 'dependabot[bot]'
            // pr.user.login === 'vHeemstra'

            // Subject --> which files are effected
            // - dependencies
            // - development
            // - documentation
            // - package

            // Semver change
            // - semver-major
            // - semver-minor
            // - semver-patch
            // - semver-none
